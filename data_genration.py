"""
This script generates training data for the SYK_ML project.
The data consists of SYK ground states and Haar random states.
The SYK ground states are generated by diagonalizing the SYK Hamiltonian.
The Haar random states are generated by sampling from a uniform distribution on the unit sphere.
The data is saved to a CSV file.
"""

import multiprocessing as mp
import time
import warnings

import numpy as np
import pandas as pd

# Suppress warnings
warnings.filterwarnings("ignore")


def tensor(a, i, N, p=2):
    """
    Create a tensor product of matrix 'a' at the ith position in a Hilbert space of N qudits.

    Parameters:
        a (ndarray): pxp Unitary matrix for a single qudit.
        i (int): Position in the tensor product (1-indexed).
        N (int): Total number of qudits.
        p (int): Degree of freedom per site (default is 2 for qubits).

    Returns:
        A (ndarray): Resulting matrix after tensor product.
    """
    dim1 = int(p ** (i - 1))
    dim2 = int(p ** (N - i))
    return np.kron(np.kron(np.identity(dim1), a), np.identity(dim2))


def majorana(N):
    """
    Create a representation of N Majorana fermions.

    Parameters:
        N (int): Number of Majorana fermions (must be even).

    Returns:
        Xi (ndarray): Representation of Majorana fermions.
    """
    if N % 2 != 0:
        raise ValueError("N must be even.")

    # SU(2) matrices
    X = np.array([[0, 1], [1, 0]], dtype=complex)
    Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
    Z = np.array([[1, 0], [0, -1]], dtype=complex)

    dim = int(2 ** (N / 2))
    Xi = np.zeros((dim, dim, N), dtype=complex)

    Zs = np.eye(dim, dtype=complex)

    for i in range(1, N + 1):
        xi = tensor(
            X if i % 2 == 1 else Y,
            (i + 1) // 2 if i % 2 == 1 else i // 2,
            N // 2,
        )
        Xi[:, :, i - 1] = np.dot(Zs, xi)

        if i % 2 == 0:
            Zs = np.dot(Zs, tensor(Z, i // 2, N // 2))

    return Xi / np.sqrt(2)  # Kitaev's normalization


def syk_hamiltonian(N, J, Xi):
    """
    Construct the SYK Hamiltonian for a given number of Majorana fermions.

    Parameters:
        N (int): Number of Majorana fermions (must be even and greater than 4).
        J (float): Disorder strength.
        Xi (ndarray): Majorana fermion representation.

    Returns:
        H (ndarray): The SYK Hamiltonian.
    """
    if N % 2 != 0 or N < 4:
        raise ValueError("N must be even and greater than 4.")

    H_length = 2 ** (N // 2)
    H = np.zeros((H_length, H_length), dtype=complex)

    sigma = np.sqrt(
        np.math.factorial(3) * J ** 2 / ((N - 1) * (N - 2) * (N - 3))
    )

    for j in range(1, N + 1):
        for k in range(j + 1, N + 1):
            for l in range(k + 1, N + 1):
                for m in range(l + 1, N + 1):
                    J_jklm = np.random.randn() * sigma
                    H += J_jklm * np.dot(
                        np.dot(
                            np.dot(Xi[:, :, j - 1], Xi[:, :, k - 1]),
                            Xi[:, :, l - 1],
                        ),
                        Xi[:, :, m - 1],
                    )

    return H


def haar_random_state(dimension):
    """
    Generate a Haar random state (normalized complex vector).

    Parameters:
        dimension (int): Dimension of the Hilbert space.

    Returns:
        normalized_vector (ndarray): Normalized random complex vector.
    """
    random_vector = np.random.normal(0, 1, size=(dimension,))
    return random_vector / np.linalg.norm(random_vector)


def generate_syk_and_haar_states(N_sample, N, disorder_strength, Xi):
    """
    Generate SYK and Haar random states.

    Parameters:
        N_sample (int): Number of samples to generate.
        N (int): Number of Majorana fermions.
        disorder_strength (float): Strength of the disorder.
        Xi (ndarray): Majorana fermion representation.

    Returns:
        pd.DataFrame: Concatenated DataFrame of generated data.
    """
    hilbert_space_dimension = 2 ** (N // 2)
    X = np.empty((N_sample, hilbert_space_dimension + 1))
    y = np.zeros((N_sample, hilbert_space_dimension + 1))
    z = np.zeros((N_sample * 2, hilbert_space_dimension + 1))

    for k in range(N_sample):
        # Generate Haar random state
        X[k, :hilbert_space_dimension] = haar_random_state(
            hilbert_space_dimension
        )
        z[k + N_sample, :] = X[k, :]

        # Generate SYK ground state
        H = syk_hamiltonian(N, disorder_strength, Xi)
        eigenvalues, eigenvectors = np.linalg.eigh(H)
        y[k, :hilbert_space_dimension] = eigenvectors[0] / np.linalg.norm(
            eigenvectors[0]
        )
        z[k, :] = y[k, :]

    column_names = [f"C_WF_{i}" for i in range(hilbert_space_dimension)]
    z1 = pd.DataFrame(z[:, :hilbert_space_dimension], columns=column_names)
    z2 = pd.DataFrame(z[:, hilbert_space_dimension] > 0.1, columns=["is_SYK"])
    return pd.concat([z1, z2], axis=1)


def parallel_data_generation(N_total, N, disorder_strength, n_jobs=-1):
    """
    Generate a DataFrame with SYK and Haar random states in parallel.

    Parameters:
        N_total (int): Total number of samples to generate.
        N (int): Number of Majorana fermions.
        disorder_strength (float): Strength of the disorder.
        n_jobs (int): Number of processors for parallel computing (-1 for maximum).

    Returns:
        pd.DataFrame: DataFrame containing generated data.
    """
    if n_jobs == -1:
        n_jobs = mp.cpu_count()

    print(f"Running with {n_jobs} jobs")
    Xi = majorana(N)

    # Create a pool of worker processes
    with mp.Pool(n_jobs) as pool:
        # Map the generate_syk_and_haar_states function to the pool of workers
        results = pool.starmap(
            generate_syk_and_haar_states,
            [
                (N_total // n_jobs, N, disorder_strength, Xi)
                for _ in range(n_jobs)
            ],
        )

    # Concatenate the results from all workers
    return pd.concat(results, ignore_index=True)


def main():
    """
    Main function to generate and save the data.
    """
    # Parameters for data generation
    N = 8  # Number of Majorana fermions (must be even for SYK)
    disorder_strength = 1.0
    num_samples = 1000

    # Generate data
    print("Generating data...")
    start_time = time.time()
    data_frame = parallel_data_generation(
        num_samples, N, disorder_strength, n_jobs=-1
    )
    end_time = time.time()
    print(f"Data generation took {end_time - start_time:.2f} seconds.")

    # Save data to a CSV file
    file_path = f"SYK_data_N{N}.csv"
    print(f"Saving data to {file_path}...")
    data_frame.to_csv(file_path, index=False)
    print("Data saved successfully.")


if __name__ == "__main__":
    main()